use std::io::{self, Read, Write};
use std::net::{Shutdown, SocketAddr, TcpListener, TcpStream};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::{Arc, mpsc};
use std::thread::{self, JoinHandle};
use std::time::Duration;

/// the purpose of this enum is for tcplistener thread to be
/// able to emmit stuff to the GUI
enum TcpServerEvent {
    AddClient(Arc<TcpStream>),
    DelClient(SocketAddr),
}

pub struct TcpServer {
    listener: Option<Arc<TcpListener>>,
    is_running: Arc<AtomicBool>,
    worker: Option<JoinHandle<()>>,

    // these 2 are needed for inner thread to send
    // stuff out without using arc<mutex>
    event_tx: mpsc::Sender<TcpServerEvent>,
    event_rx: mpsc::Receiver<TcpServerEvent>,

    pub clients: Vec<Arc<TcpStream>>,
}

impl Default for TcpServer {
    fn default() -> Self {
        let (event_tx, event_rx) = mpsc::channel();

        TcpServer {
            listener: None,
            is_running: Arc::new(AtomicBool::new(false)),
            worker: None,
            event_tx,
            event_rx,
            clients: vec![],
        }
    }
}

impl Drop for TcpServer {
    fn drop(&mut self) {
        log::debug!("server dropped");
        self.disconnect();
    }
}

impl TcpServer {
    pub fn is_up(&self) -> bool {
        self.is_running.load(Ordering::Relaxed)
    }

    pub fn is_connected(&self) -> bool {
        self.listener.is_some()
    }

    /// generated by ai
    fn get_sockaddr(&self) -> Option<SocketAddr> {
        self.listener.as_ref().and_then(|l| l.local_addr().ok())
        // .map(|addr| addr.port().to_string())
    }

    /// why not propagate the errors to GUI caller
    /// because in case of failure, the GUI cannnot do anything but
    /// print the error message, and re-press the button to
    /// try to re-start
    pub fn begin(&mut self, sockaddr: String) -> Option<String> {
        let port = match self.connect(&sockaddr) {
            Ok(port) => port,
            Err(e) => {
                log::error!("cannot connect to {sockaddr}, {e}");
                return None;
            }
        };

        self.start_worker();
        Some(port)
    }

    /// binds a tcplistener and return the actual port being used
    fn connect(&mut self, sockaddr: &str) -> io::Result<String> {
        if self.is_connected() {
            self.disconnect();
        }

        let listener = TcpListener::bind(sockaddr)?;

        let port = listener.local_addr()?.port().to_string();

        // listener needs to work in a polling fashion (non-blocking)
        // so that we can turn it off with a atomicbool flag
        listener.set_nonblocking(true)?;
        self.listener = Some(Arc::new(listener));

        log::info!("server bind to: {:?}", self.get_sockaddr());
        Ok(port)
    }

    fn start_worker(&mut self) {
        // we cannot directly return here because the socket
        // might have changed and we need to start a new worker
        if self.is_up() {
            self.stop_worker();
        }

        // make a copy to be used in thread
        let is_running = self.is_running.clone();
        let Some(listener) = self.listener.as_ref().cloned() else {
            log::error!("cannot start server thread, no listener found");
            return;
        };
        let event_tx = self.event_tx.clone();

        // spawn thread, outer listener thread
        self.is_running.store(true, Ordering::Relaxed);
        let handle = thread::spawn(move || {
            for stream_result in listener.incoming() {
                // this provides the escape of the for loop
                // for this to work tcplistener should run in nonblocking mode
                if !is_running.load(Ordering::Relaxed) {
                    break;
                }

                match stream_result {
                    Ok(stream) => {
                        // i don't think sockaddr::peer_addr() would fail very often
                        // but in case it did fail we would need to abort because
                        // sockaddr is also used for removing the client from server end
                        let peer_sockaddr = match stream.peer_addr() {
                            Ok(sockaddr) => sockaddr,
                            Err(e) => {
                                log::error!("unable to get incoming stream peer address: {e}");
                                break; // this will end the server's handing thread
                            }
                        };
                        log::info!("incoming client stream connected: {stream:?}");

                        let stream = Arc::new(stream);
                        let stream_clone = stream.clone();

                        // send the tcpstream to vec via channel
                        let _ = event_tx.send(TcpServerEvent::AddClient(stream));

                        // make another clone to be used in inner thread
                        let event_tx_clone = event_tx.clone();

                        // this thread should be closed automatically
                        // if the connection is terminated, to be tested
                        thread::spawn(move || {
                            let mut buffer = [0u8; 1024];
                            let mut stream_ref: &TcpStream = &stream_clone;

                            loop {
                                match stream_ref.read(&mut buffer) {
                                    // this gets called when both side terminates the connection
                                    // when EOF sent by client, the peer_addr is still available
                                    // in stream, but the connection is already closed when reached here
                                    // if the EOF is initiated by server the event is called first
                                    // then here, when reached here the peer_addr is no longer available
                                    Ok(0) => {
                                        log::info!("peer connection [{}] closed", peer_sockaddr);
                                        break;
                                    }
                                    Ok(n) => {
                                        let bytes = &buffer[..n];
                                        let msg = String::from_utf8_lossy(bytes);
                                        // log::info!("received {n} bytes from [{peer_sockaddr}]");
                                        log::info!("[TCP RECV] {:?} from {:?}", msg, peer_sockaddr);
                                    }

                                    Err(e)
                                        if e.kind() == std::io::ErrorKind::TimedOut
                                            || e.kind() == std::io::ErrorKind::WouldBlock =>
                                    {
                                        thread::sleep(Duration::from_millis(100));
                                    }

                                    // other errors might indicate broken or disconnected stream
                                    // so we need to break to end the client handling thread
                                    Err(e) => {
                                        log::error!(
                                            "reading from stream {:?} error, {}",
                                            stream_ref,
                                            e
                                        );
                                        break;
                                    }
                                }
                            }
                            let _ = event_tx_clone.send(TcpServerEvent::DelClient(peer_sockaddr));
                            log::debug!("server's handling thread for [{peer_sockaddr}] is ended");
                        });
                    }

                    Err(e)
                        if e.kind() == std::io::ErrorKind::WouldBlock
                            || e.kind() == std::io::ErrorKind::TimedOut =>
                    {
                        thread::sleep(Duration::from_millis(100));
                    }
                    Err(e) => {
                        log::error!("accept incoming stream error = {}", e);
                        break;
                    }
                }
            }
            log::debug!("server thread terminating: {:?} ", thread::current());
        });

        log::info!("server thread started: {:?}", handle.thread());
        self.worker = Some(handle);
    }

    /// stopping the thread
    fn stop_worker(&mut self) {
        self.is_running.store(false, Ordering::Relaxed);

        if !self.clients.is_empty() {
            log::info!(">>> shutting down connected clients");
            log::debug!("clients connected = {:?}", self.clients);

            for stream in self.clients.drain(..) {
                if let Err(e) = stream.shutdown(Shutdown::Both) {
                    log::error!("error shutting down stream {:?}, {e}", stream);
                }
            }
        }

        if let Some(worker) = self.worker.take() {
            match worker.join() {
                Ok(_) => log::info!("server thread terminated ok"),
                Err(e) => log::error!("terminating server thread error: {e:?}"),
            }
        }
    }

    /// stops the server thread and drop the listener
    pub fn disconnect(&mut self) {
        self.stop_worker();
        self.listener.take();
    }

    pub fn poll_events(&mut self) {
        for ev in self.event_rx.try_iter() {
            match ev {
                TcpServerEvent::AddClient(s) => {
                    self.clients.push(s);
                }
                TcpServerEvent::DelClient(sock) => {
                    self.clients
                        .retain(|s| s.peer_addr().map_or(false, |a| a != sock));

                    // with this approach, the shutdown returns error
                    // because when we get the signal to delete the stream
                    // the stream is already disconnected,
                    // if let Some(idx) = self
                    //     .clients
                    //     .iter()
                    //     .position(|s| s.peer_addr().ok() == Some(sock))
                    // {
                    //     // pop the stream from vec
                    //     let stream = self.clients.remove(idx);
                    //     log::debug!("stream to remove = {:?}", stream);

                    //     // shutdown
                    //     match stream.shutdown(Shutdown::Both) {
                    //         Ok(()) => log::debug!("{:?} removed and shuts down", stream),
                    //         Err(e) => log::error!("unable to shutdown {:?}, {e}", stream),
                    //     }

                    //     log::debug!("stream after shutdown  = {:?}", stream);
                    // }
                }
            }
        }
    }

    pub fn close_client(&self, peer: SocketAddr) {
        // solution offered by ai
        // iter through the vec, find the stream then shutdown the stream
        // but it does not remove it instantly from the vec
        if let Some(s) = self
            .clients
            .iter()
            .find(|s| s.peer_addr().ok() == Some(peer))
        {
            match s.shutdown(Shutdown::Both) {
                Ok(()) => log::info!("peer connection [{peer}] close by server"),
                Err(e) => log::info!("unable to close peer connection [{peer}], {e}"),
            }
        }

        // alternative approach, use the event channel we have
        let _ = self.event_tx.send(TcpServerEvent::DelClient(peer));
    }

    pub fn send_data(&self, msg: &str, stream: &Arc<TcpStream>) {
        let mut stream: &TcpStream = &stream;
        let data = msg.as_bytes();

        match stream.write_all(&data) {
            Ok(()) => log::info!("[TCP SEND] {msg:?}"),
            Err(e) => log::error!("error sending data via stream: {e}"),
        }
    }
}

pub struct TcpClient {
    stream: Option<Arc<TcpStream>>,
    is_running: Arc<AtomicBool>,
    worker: Option<JoinHandle<()>>,
}

impl Default for TcpClient {
    fn default() -> Self {
        Self {
            stream: None,
            is_running: Arc::new(AtomicBool::new(false)),
            worker: None,
        }
    }
}

impl TcpClient {
    pub fn is_up(&self) -> bool {
        self.is_running.load(Ordering::Relaxed)
    }

    /// notice the local port cannot be manually assigned
    /// TcpStream::connect always uses ephemeral local port unless
    /// you find first, to bind we need to use other crates like socket2
    fn connect_to_server(&mut self, sockaddr: &str) -> io::Result<SocketAddr> {
        let stream = TcpStream::connect(sockaddr)?;
        stream.set_nonblocking(true)?;
        let sockaddr = stream.local_addr()?;
        log::info!("connected to server, {:?}", stream);
        self.stream = Some(Arc::new(stream));
        Ok(sockaddr)
    }

    pub fn begin(&mut self, sockaddr: &str) -> Option<SocketAddr> {
        let sockaddr = match self.connect_to_server(sockaddr) {
            Ok(sockaddr) => sockaddr,
            Err(e) => {
                log::error!("error connecting to TCP server {sockaddr}, {e}");
                return None;
            }
        };

        self.start_worker();
        Some(sockaddr)
    }

    fn start_worker(&mut self) {
        if self.is_up() {
            self.stop_worker();
        }

        // prepare clones for thread
        let Some(stream) = self.stream.as_ref().cloned() else {
            log::error!("cannot start client thread, no stream found");
            return;
        };
        let is_running = self.is_running.clone();

        // set state right before thread starts
        is_running.store(true, Ordering::Relaxed);
        let handle = thread::spawn(move || {
            let mut buffer = [0u8; 1024];
            let mut stream_ref: &TcpStream = &stream;
            while is_running.load(Ordering::Relaxed) {
                match stream_ref.read(&mut buffer) {
                    Ok(0) => {
                        log::info!("connection closed by server end (EOF)");
                        break;
                    }
                    Ok(n) => {
                        let bytes = &buffer[..n];
                        let msg = String::from_utf8_lossy(bytes);
                        log::info!("[TCP RECV] {:?} from {:?}", msg, stream.peer_addr());
                    }
                    Err(e)
                        if e.kind() == std::io::ErrorKind::TimedOut
                            || e.kind() == std::io::ErrorKind::WouldBlock =>
                    {
                        thread::sleep(Duration::from_millis(100));
                    }
                    Err(e) => {
                        log::error!("tcp client receiving error, {}", e);
                        break;
                    }
                }
            }

            // todo we need a manual repaint here because at
            // this moment the client is considered no_up
            log::debug!("client thread's while loop ended");
            is_running.store(false, Ordering::Relaxed);
        });
        log::info!("client thread started: {:?}", handle.thread());
        self.worker = Some(handle);
    }

    fn stop_worker(&mut self) {
        // set flag to stop the thread
        self.is_running.store(false, Ordering::Relaxed);

        // make sure worker thread is terminated
        if let Some(worker) = self.worker.take() {
            match worker.join() {
                Ok(_) => log::info!("client thread terminated ok"),
                Err(e) => log::error!("terminating client thread error: {e:?}"),
            }
        }
    }

    pub fn disconnect(&mut self) {
        self.stop_worker();

        // drop the stream so that the server can close the connection
        if let Some(stream) = self.stream.take() {
            if let Err(e) = stream.shutdown(Shutdown::Both) {
                log::error!("failed to shutdown tcpclient stream: {e}");
            }
        }
    }

    pub fn send_data(&self, msg: &str) {
        if let Some(ref stream_ref) = self.stream {
            let mut stream: &TcpStream = &stream_ref;
            let data = msg.as_bytes();

            match stream.write_all(&data) {
                Ok(()) => log::info!("[TCP SEND] {:?} to {:?}", msg, stream_ref.peer_addr()),
                Err(e) => log::error!("error sending data via stream: {e}"),
            }
        } else {
            log::error!("error sending data, no stream available");
        }
    }
}
